#' @title Calculate Prediction Loss for a Specific TG-TF Pair
#'
#' @description
#' This function computes the prediction loss (mean squared error) for a specific target gene-transcription factor (TG-TF) pair using optimized model parameters.
#' It evaluates how well the trained model predicts the expression dynamics of TFE, TGA, and TGE across multiple time points.
#'
#' @param TG_TF
#' Character. A string identifier for the specific TG-TF pair in the format "TG_<target_gene>~<transcription_factor>_TF" (eg. TG_TP53~JUND_TF).
#' This is used to extract the appropriate target gene and transcription factor identifiers.
#' @param data
#' Data frame. The dataset containing expression values for the TG-TF pair,
#' typically including columns for TFE, TGA, TGE across multiple time points, and the regulatory strength theta_s.
#' Typically choose one from three options: training set data, validation set data, or test set data.
#'
#' @returns
#' A numeric value representing the mean squared prediction error across all time points for the specified TG-TF pair.
#' The loss combines prediction errors for:
#' \itemize{
#' \item TFE (Transcription Factor Expression)
#' \item TGA (Target Gene Accessibility)
#' \item TGE (Target Gene Expression)
#' }
#' Lower values indicate better prediction performance.
#'
#' @details
#' The function performs the following operations:
#' \enumerate{
#' \item Parameter Extraction: Retrieves optimized parameters from the global variable \code{result_gradient$parameters}
#' \item TG-TF Identification: Parses the TG-TF identifier to extract target gene and transcription factor names
#' \item Data Extraction: Extracts TFE, TGA, and TGE expression values across time points
#' \item Parameter Retrieval: Retrieves all relevant model parameters for the specific TG-TF pair
#' \item R Function Applications.
#' \item Hill Function Applications: Computes multiple Hill functions for different regulatory components
#' \item Loss Computation: Calculates mean squared prediction errors across all time points
#' }
#' The loss function incorporates weighted squared errors for TFE, TGA, and TGE predictions, with TFE and TGA errors weighted twice as heavily as TGE errors.
#'
#' @note
#' Important considerations:
#' \itemize{
#' \item This function assumes the existence of several global variables: \code{result_gradient}, \code{branch_params_names}, \code{tao}, and \code{Tslot_K}
#' \item The function depends on optimized parameters from a previous training process
#' \item The TG-TF identifier must follow the specific format for proper parsing
#' \item The data parameter must contain the required columns with proper naming conventions
#' \item The function is typically used for model evaluation on validation or test data
#' }
#'
#' @seealso \code{\link{R_cal}}, \code{\link{Hill_cal}}, \code{\link{S_cal}}
#'
#' @export
#'
#' @examples
#' \dontrun{
#' print(loss_cal(TG_TF = "TG_TP53~JUND_TF", data = train_data))
#' }
loss_cal = function(TG_TF, data)
{
  branch_params_vec = result_gradient$parameters
  base::names(branch_params_vec) = branch_params_names

  TG = base::sub(".*_([^~]+)~.*", "\\1", TG_TF)
  TF = base::sub(".*~([^_]+)_.*", "\\1", TG_TF)

  TFE = data[TG_TF, grep("TFE_", base::colnames(data), value = TRUE)]
  TGA = data[TG_TF, grep("TGA_", base::colnames(data), value = TRUE)]
  TGE = data[TG_TF, grep("TGE_", base::colnames(data), value = TRUE)]
  Length = base::length(TFE)
  seqLength = base::seq_len(Length - 1)

  R = scDEDS::R_cal(theta_TF_TG = data[TG_TF, "theta_s"],
                    tao = tao,
                    r1 = 200,
                    r2 = (branch_params_vec[base::paste0("r.r2_TG.",TG)] +
                            branch_params_vec[base::paste0("r.r2_TF.",TF)]) / 2,
                    r3 = 1,
                    r4 = 1000,
                    r5 = 1)

  alpha1 = (branch_params_vec[base::paste0("alpha.alpha1_TG_K-1.", TG, ".", seqLength)] +
              branch_params_vec[base::paste0("alpha.alpha1_TF_K-1.", TF, ".", seqLength)]) / 2
  alpha2 = (branch_params_vec[base::paste0("alpha.alpha2_TG_K-1.", TG, ".", seqLength)] +
              branch_params_vec[base::paste0("alpha.alpha2_TF_K-1.", TF, ".", seqLength)]) / 2

  beta1 = (branch_params_vec[base::paste0("beta.beta1_TG_K-1.", TG, ".", seqLength)] +
             branch_params_vec[base::paste0("beta.beta1_TF_K-1.", TF, ".", seqLength)]) / 2
  beta2 = (branch_params_vec[base::paste0("beta.beta2_TG_K-1.", TG, ".", seqLength)] +
             branch_params_vec[base::paste0("beta.beta2_TF_K-1.", TF, ".", seqLength)]) / 2
  beta3 = branch_params_vec[base::paste0("beta.beta3_TG_K-1.", TG, ".", seqLength)]

  s1 = (branch_params_vec[base::paste0("s.s1_TG.",TG)] +
          branch_params_vec[base::paste0("s.s1_TF.",TF)]) / 2
  s2 = (branch_params_vec[base::paste0("s.s2_TG.",TG)] +
          branch_params_vec[base::paste0("s.s2_TF.",TF)]) / 2

  u11 = branch_params_vec[base::paste0("u.u11_TG.",TG)]
  u21 = branch_params_vec[base::paste0("u.u21_TG.",TG)]
  u311 = branch_params_vec[base::paste0("u.u311_TG.",TG)]
  u321 = branch_params_vec[base::paste0("u.u321_TG.",TG)]
  u331 = branch_params_vec[base::paste0("u.u331_TG.",TG)]
  u12 = branch_params_vec[base::paste0("u.u12_TG.",TG)]
  u22 = branch_params_vec[base::paste0("u.u22_TG.",TG)]
  u312 = branch_params_vec[base::paste0("u.u312_TG.",TG)]
  u322 = branch_params_vec[base::paste0("u.u322_TG.",TG)]
  u332 = branch_params_vec[base::paste0("u.u332_TG.",TG)]

  TGE_tilde = branch_params_vec[base::paste0("E~.E~_TG_K-1.", TG, ".", seqLength)]
  TFE_tilde = branch_params_vec[base::paste0("E~.E~_TF_K-1.", TF, ".", seqLength)]

  U1_tilde = scDEDS::Hill_cal(x = TGE_tilde, Dissociation_Constant = u11, Hill_Coefficient = u12)
  U2_tilde = scDEDS::Hill_cal(x = TFE_tilde, Dissociation_Constant = u21, Hill_Coefficient = u22)
  U1 = scDEDS::Hill_cal(x = TGE[-Length], Dissociation_Constant = u11, Hill_Coefficient = u12)
  U2 = scDEDS::Hill_cal(x = TFE[-Length], Dissociation_Constant = u21, Hill_Coefficient = u22)
  U31 = scDEDS::Hill_cal(x = TGA[-Length], Dissociation_Constant = u311, Hill_Coefficient = u312)
  U32 = scDEDS::Hill_cal(x = TGE[-Length], Dissociation_Constant = u321, Hill_Coefficient = u322)
  U33 = scDEDS::Hill_cal(x = TGE_tilde[-Length], Dissociation_Constant = u331, Hill_Coefficient = u332)

  v1 = branch_params_vec[base::paste0("v.v1_TG.", TG)]
  v2 = branch_params_vec[base::paste0("v.v2_TG.", TG)]
  v3 = branch_params_vec[base::paste0("v.v3_TG.", TG)]

  # Computing the objective function for this sample.
  base::mean(base::as.numeric(base::sapply(2:Length, function(K) {
    prev_idx = K - 1
    2 * (TFE[prev_idx] + alpha1[prev_idx] * R * scDEDS::S_cal(
      s = s1,
      U = U1[prev_idx],
      U_tilde = U1_tilde[prev_idx]) + beta1[prev_idx] - TFE[K])^2 + 2 * (
        TGA[prev_idx] + alpha2[prev_idx] * R * scDEDS::S_cal(
          s = s2, U = U2[prev_idx], U_tilde = U2_tilde[prev_idx]
        ) + beta2[prev_idx] - TGA[K]
      )^2 + (
        TGE[prev_idx] + R * (
          v1 * U31[prev_idx] - v2 * U32[prev_idx] - v3 * U33[prev_idx]
        ) * Tslot_K[K] + beta3[prev_idx] - TGE[K]
      )^2
  })))
}
