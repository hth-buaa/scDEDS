#' @title Optimize Regulatory Strength Parameter (theta) for TG-TF Pair
#'
#' @description
#' This function optimizes the regulatory strength parameter (theta) for a specific target gene-transcription factor (TG-TF) pair using trained model parameters.
#' It employs the Brent optimization method to find the theta value that minimizes the prediction error for expression dynamics across multiple time points.
#'
#'
#' @param TG_TF See in ?loss_cal.
#' @param data See in ?loss_cal.
#' @param best_para_vec Numeric vector. Optimized model parameters obtained from previous training, typically generated by gradient ascent optimization.
#'
#' @returns
#' A numeric value representing the optimized regulatory strength parameter (theta) that minimizes the prediction error for the given TG-TF pair.
#' The value is constrained between 0.01 and 0.99.
#'
#' @details
#' The function performs the following optimization process:
#' \enumerate{
#' \item Parameter Preparation: Converts input parameters to named vector using global variable \code{branch_params_names}
#' \item Expression Data Extraction: Retrieves TFE, TGA, and TGE time series data
#' \item Using \code{R_cal}
#' \item Parameter Retrieval: Extracts all relevant model parameters for the TG-TF pair
#' \item Hill Function Applications: Computes multiple Hill functions for regulatory components
#' \item Objective Function: Calculates mean squared prediction errors across time points
#' \item Optimization: Uses Brent's method to find theta that minimizes the objective function
#' }
#' The optimization is constrained to theta values between 0.01 and 0.99 to ensure biological plausibility and numerical stability.
#'
#' @note
#' Important considerations:
#' \itemize{
#' \item Requires global variables: \code{branch_params_names}, \code{tao}, and \code{Tslot_K}
#' \item The function assumes the input parameters are from a previously trained model
#' \item Optimization uses Brent's method which is efficient for 1-dimensional problems
#' \item The TG-TF identifier must follow the specific format for proper parsing
#' \item The data parameter must contain the required expression time series
#' \item The function is typically used for fine-tuning regulatory strength in validated models
#' }
#'
#' @seealso \code{\link{optim}}, \code{\link{R_cal}}, \code{\link{Hill_cal}}, \code{\link{S_cal}}
#'
#' @export
#'
#' @examples
#' \dontrun{
#' print(theta_p_cal(TG_TF = TG_TF, data = train_data, best_para_vec = best_para_vec))
#' }
theta_p_cal = function(TG_TF, data,
                       best_para_vec = best_para_vec)
{
  best_para_vector = base::as.numeric(best_para_vec)

  base::names(best_para_vector) = branch_params_names
  stats::optim(
    par = tao,
    fn = function(theta) {
      TG = base::sub(".*_([^~]+)~.*", "\\1", TG_TF)
      TF = base::sub(".*~([^_]+)_.*", "\\1", TG_TF)

      TFE = data[TG_TF, grep("TFE_", base::colnames(data), value = TRUE)]
      TGA = data[TG_TF, grep("TGA_", base::colnames(data), value = TRUE)]
      TGE = data[TG_TF, grep("TGE_", base::colnames(data), value = TRUE)]
      Length = base::length(TFE)
      seqLength = base::seq_len(Length - 1)

      R = R_cal(
        theta_TF_TG = theta,
        tao = tao,
        r1 = 200,
        r2 = (best_para_vector[base::paste0("r.r2_TG.",TG)] +
                best_para_vector[base::paste0("r.r2_TF.",TF)]) / 2,
        r3 = 1,
        r4 = 1000,
        r5 = 1
      )

      alpha1 = (best_para_vector[base::paste0("alpha.alpha1_TG_K-1.", TG, ".", seqLength)] +
                  best_para_vector[base::paste0("alpha.alpha1_TF_K-1.", TF, ".", seqLength)]) / 2
      alpha2 = (best_para_vector[base::paste0("alpha.alpha2_TG_K-1.", TG, ".", seqLength)] +
                  best_para_vector[base::paste0("alpha.alpha2_TF_K-1.", TF, ".", seqLength)]) / 2

      beta1 = (best_para_vector[base::paste0("beta.beta1_TG_K-1.", TG, ".", seqLength)] +
                 best_para_vector[base::paste0("beta.beta1_TF_K-1.", TF, ".", seqLength)]) / 2
      beta2 = (best_para_vector[base::paste0("beta.beta2_TG_K-1.", TG, ".", seqLength)] +
                 best_para_vector[base::paste0("beta.beta2_TF_K-1.", TF, ".", seqLength)]) / 2
      beta3 = best_para_vector[base::paste0("beta.beta3_TG_K-1.", TG, ".", seqLength)]

      s1 = (best_para_vector[base::paste0("s.s1_TG.", TG)] +
              best_para_vector[base::paste0("s.s1_TF.", TF)]) / 2
      s2 = (best_para_vector[base::paste0("s.s2_TG.", TG)] +
              best_para_vector[base::paste0("s.s2_TF.", TF)]) / 2

      u11 = best_para_vector[base::paste0("u.u11_TG.", TG)]
      u21 = best_para_vector[base::paste0("u.u21_TG.", TG)]
      u311 = best_para_vector[base::paste0("u.u311_TG.", TG)]
      u321 = best_para_vector[base::paste0("u.u321_TG.", TG)]
      u331 = best_para_vector[base::paste0("u.u331_TG.", TG)]
      u12 = best_para_vector[base::paste0("u.u12_TG.", TG)]
      u22 = best_para_vector[base::paste0("u.u22_TG.", TG)]
      u312 = best_para_vector[base::paste0("u.u312_TG.", TG)]
      u322 = best_para_vector[base::paste0("u.u322_TG.", TG)]
      u332 = best_para_vector[base::paste0("u.u332_TG.", TG)]

      TGE_tilde = best_para_vector[base::paste0("E~.E~_TG_K-1.", TG, ".", seqLength)]
      TFE_tilde = best_para_vector[base::paste0("E~.E~_TF_K-1.", TF, ".", seqLength)]

      U1_tilde = scDEDS::Hill_cal(x = TGE_tilde, Dissociation_Constant = u11, Hill_Coefficient = u12)
      U2_tilde = scDEDS::Hill_cal(x = TFE_tilde, Dissociation_Constant = u21, Hill_Coefficient = u22)
      U1 = scDEDS::Hill_cal(x = TGE[-Length], Dissociation_Constant = u11, Hill_Coefficient = u12)
      U2 = scDEDS::Hill_cal(x = TFE[-Length], Dissociation_Constant = u21, Hill_Coefficient = u22)
      U31 = scDEDS::Hill_cal(x = TGA[-Length], Dissociation_Constant = u311, Hill_Coefficient = u312)
      U32 = scDEDS::Hill_cal(x = TGE[-Length], Dissociation_Constant = u321, Hill_Coefficient = u322)
      U33 = scDEDS::Hill_cal(x = TGE_tilde[-Length], Dissociation_Constant = u331, Hill_Coefficient = u332)

      v1 = best_para_vector[base::paste0("v.v1_TG.", TG)]
      v2 = best_para_vector[base::paste0("v.v2_TG.", TG)]
      v3 = best_para_vector[base::paste0("v.v3_TG.", TG)]

      # Calculate the objective function of this sample.
      base::mean(base::as.numeric(base::sapply(2:Length, function(K) {
        prev_idx = K - 1
        2 * (
          TFE[prev_idx] + alpha1[prev_idx] * R * scDEDS::S_cal(
            s = s1, U = U1[prev_idx], U_tilde = U1_tilde[prev_idx]
          ) + beta1[prev_idx] - TFE[K]
        )^2 + 2 * (
          TGA[prev_idx] + alpha2[prev_idx] * R * scDEDS::S_cal(
            s = s2, U = U2[prev_idx], U_tilde = U2_tilde[prev_idx]
          ) + beta2[prev_idx] - TGA[K]
        )^2 + (
          TGE[prev_idx] + R * (
            v1 * U31[prev_idx] - v2 * U32[prev_idx] - v3 * U33[prev_idx]
          ) * Tslot_K[K] + beta3[prev_idx] - TGE[K]
        )^2
      })))
    },
    lower = 0.01, upper = 0.99, method = "Brent")$par
}
